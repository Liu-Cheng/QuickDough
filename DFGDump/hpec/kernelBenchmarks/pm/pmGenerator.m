function pmGenerator(DataSetNum, NoiseLevel, SigLevel1, SigLevel2, RandLevel, PatternLength, LibPatterns)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File: pmGenerator.m
%
% HPEC Challenge Benchmark Suite
% Pattern Match Dataset Generator Matlab Function 
%
% function pmGenerator(DataSetNum, NoiseLevel, SigLevel1, SigLevel2, RandLevel, PatternLength, LibPatterns)
%
%   Generates a library of patterns and the test pattern for the Pattern
%   Match kernel.  In general, each of the pattern in the pattern library 
%   will have the pattern like the figure below.  The number of pulses will
%   be equal to the number of ones of the index number of the pattern in 
%   binary form.  The test pattern is generated by distorting a randomly
%   chosen pattern from the pattern library.
%
%                        _          _                        <- SigLevel2
%                       | |        | |
%    width=4            | |        | |            width=4
%     |   |             | |        | |             |   |
%   ->|   |<-           | |        | |           ->|   |<-
%                       | |        | |
%          _____________| |________| |_____________          <- SigLevel1
%         |                                        |
%      ___|                                        |___      <- NoiseLevel
%     |________________________________________________|     <- zero
%
%     |----------------- PatternLength ----------------|
%
%   Inputs:
%     DataSetNum    - the pattern library and test pattern will be written to
%                     files in the following format: <DataSetNum>-pm-<desc>.dat
%     NoiseLevel    - see above figure
%     SigLevel1     - see above figure
%     SigLevel2     - see above figure
%     RandLevel     - this is the measure of the distortion of the test pattern
%     PatternLength - see above figure
%     LibPatterns   - this specifies the number of patterns in the library
%
%   Outputs:
%     Files: ./data/<DataSetNum>-pm-lib.dat     - the pattern library
%            ./data/<DataSetNum>-pm-pattern.dat - the test pattern
%            ./data/<DataSetNum>-pm-patnum.dat  - the index of the test pattern in
%                                                 the pattern library
%   Example:
%     pmGen(1, 0.1, 10, 40, 0.02, 64, 72);
%       DataSetNum    = 1
%       NoiseLevel    = 0.1;
%       SigLevel1     = 10;
%       SigLevel2     = 40;
%       RandLevel     = 0.02;
%       PatternLength = 64;
%       LibPatterns   = 72;
%
%   Author:   James Lebak, Hector Chan
%             MIT Lincoln Laboratory
%

% Output file names
libFile        = ['./data/' num2str(DataSetNum) '-pm-lib.dat'];
testPatFile    = ['./data/' num2str(DataSetNum) '-pm-pattern.dat'];
OrigPatNumFile = ['./data/' num2str(DataSetNum) '-pm-origpatnum.dat'];

% Check if the data set already exists
if(exist(libFile, 'file') | exist(testPatFile, 'file') | exist(OrigPatNumFile, 'file'))
  ret = input('Files for this data set number exist.  Would you like to overwrite them? (y/n) ', 's');
  if ~strcmpi(ret, 'y')
    disp('Exiting');
    return;
  end 
end 

disp(['Pattern Length = ' num2str(PatternLength) ', Number of Templates = ' num2str(LibPatterns)]);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generate the pattern template libraray
%

disp('Generating the template library');

FIELDVECTOR = [ 0 1 1 0 ];
FIELDLENGTH = length(FIELDVECTOR);

% The number of patterns we can generate is limited by the length of each
% pattern: check that the requested number of patterns is possible
patternBits = (PatternLength - 4*FIELDLENGTH) / FIELDLENGTH;
if (log2(LibPatterns) > patternBits)
    error(['Unable to generate the required number of patterns with the' ...
	   ' specified length!']);
end

% Build a pattern to serve as the starting point for construction
basePattern = NoiseLevel*ones(1,PatternLength);

midLength = PatternLength - 2*FIELDLENGTH;
basePattern( (FIELDLENGTH+1):(PatternLength-FIELDLENGTH) ) = SigLevel1* ...
    ones(1,midLength); 

for ix = 1:LibPatterns
    % Initialize the pattern to zero
    lib(ix,:) = basePattern;

    patternCode = ix-1;
    for ib = patternBits:-1:1
	% Introduce zeros and ones into the pattern based on the binary
        % representation of the pattern's number
	currPow2 = 2^(ib-1);
	bitValue = fix(patternCode / currPow2);

	bitIndex = 2*FIELDLENGTH + (1:FIELDLENGTH) + FIELDLENGTH*(ib-1);

	lib(ix,bitIndex) = SigLevel1 + bitValue*SigLevel2*FIELDVECTOR;

	% Remove the most significant bits first
	patternCode = patternCode - bitValue*currPow2;
    end % for ib
end % for ix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generate the random patterns to test
% Choose one pattern and distort it
%

[nPatterns, dummy] = size(lib);
testPatNum = 1+fix(nPatterns*rand);
testPat = lib(testPatNum,:);

disp(['Distorting pattern number ' num2str(testPatNum) ' from lib as test pattern']);

% Add noise to the test pattern
testPat = testPat + (RandLevel*randn(size(testPat)).*testPat);

% Shift the pattern by up to 5% in either direction
shiftAmount = fix(0.05*PatternLength*rand);
shiftInd = shiftAmount+1;

if (shiftAmount ~= 0)
    if (rand < 0.5)
        % Shift negatively
        testPat = [testPat(shiftInd:PatternLength) NoiseLevel*ones(1, shiftAmount)];
    else
        % Shift positively
        testPat = [NoiseLevel*ones(1, shiftAmount) ...
                   testPat(1:(PatternLength - shiftAmount)) ];
    end
end

if (testPat(1) > NoiseLevel)
    testPat(1) = NoiseLevel;
end

if (testPat(end) > NoiseLevel)
	testPat(end) = NoiseLevel;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Write the input to files
% 
disp(['lib data is stored in ' libFile]);
disp(['test pattern data is stored in ' testPatFile]);
disp(['original index data is stored in ' OrigPatNumFile]);

oldPath = path;
addpath('../matlab');
writeFile(libFile, lib, 'float32');
writeFile(testPatFile, testPat, 'float32');
writeFile(OrigPatNumFile, testPatNum, 'int32');
path(oldPath);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2006, Massachusetts Institute of Technology
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are  
% met:
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%     * Neither the name of the Massachusetts Institute of Technology nor  
%       the names of its contributors may be used to endorse or promote 
%       products derived from this software without specific prior written 
%       permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  
% THE POSSIBILITY OF SUCH DAMAGE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
