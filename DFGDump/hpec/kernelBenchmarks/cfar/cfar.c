/******************************************************************************
** File: cfar.c
**
** HPEC Challenge Benchmark Suite
** CFAR Kernel Benchmark
**
** Contents:
**  The C version of the CFAR kernel benchmark.  Searches for targets
**  placed in a uniform noise data cube.
**
** Input files (generated by cfarGenerator.m)
**  data/<id>-cfar-param.dat - CFAR parameters
**  data/<id>-cfar-cube.dat  - CFAR data cube
**
** Output files: 
**  data/<id>-cfar-detect.dat - the targets detected by CFAR 
**  data/<id>-cfar-timing.dat - time for running the CFAR kernel
**
** Author: Edmund L. Wong 
**         MIT Lincoln Laboratory
**
******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <PcaCTimer.h>
#include <PcaCArray.h>
#include "targetlist.h"
#include <assert.h>

/* the number of blocks to allocate at once (using MemManager) */
#define NUM_MM_BLOCKS 10

/* parameters */
typedef struct
{
  uint nbm;   /* number of beams (dimension of the data cube) */
  uint ndop;  /* number of dopplers (dimension of the data cube) */
  uint nrg;   /* number of range gates (dimension of the data cube) */
  uint ncfar; /* number of adjacent cells to use in noise estimate */
  uint gcl;   /* number of guard cells (not part of noise estimate) */
  uint mu;    /* threshold for a target */
  struct PcaCArrayFloat C_in; /* data cube */
} CfarState;


/**************************************************************************
* Loads the CFAR parameters and data cube from the specified files.
**************************************************************************/
void initCfar(CfarState* p_cfar, const char* m_paramfile, 
	      const char* m_cubefile)
{
  /* the arrays to pull in */
  struct PcaCArrayInt dataset_in;

  /* read the data from the specified files */
  readFromFile(int, m_paramfile, dataset_in);
  readFromFile(float, m_cubefile, p_cfar->C_in);

  /* load parameters */
  p_cfar->gcl = dataset_in.data[0];
  p_cfar->nbm = dataset_in.data[1];
  p_cfar->ncfar = dataset_in.data[2];
  p_cfar->ndop = dataset_in.data[3];
  p_cfar->nrg = dataset_in.data[4];
  p_cfar->mu = dataset_in.data[5];

  /* clean up input arrays */
  clean_mem(int, dataset_in);
}



/**************************************************************************
* The CFAR function.  Note that the CFAR modifies the data cube 
* and thus it cannot be run twice without re-running initCfar().
* 
* Note that this function makes use of software pipelining in many
* of its inner loops.  What this does is distances the calculation
* of the noise estimate (sp_sum vs. sum) from its actual use, thus 
* allowing better performance.  However, as a result, each inner loop
* is preceded by a setup phase to prime the pipeline and a finish phase
* to finish up any leftover calculations.
**************************************************************************/
void cfar(CfarState* p_cfar, CfarTargetList* p_targetlist)
{
  /* parameters */
  uint gcl = p_cfar->gcl;
  uint nbm = p_cfar->nbm;
  uint ncfar = p_cfar->ncfar;
  uint ndop = p_cfar->ndop;
  uint nrg = p_cfar->nrg;

  /* various counters */
  uint i, j, k, k_diff = nrg-gcl-ncfar;

  /* used to maintain the sum for background noise, etc. */
  register float sum;    /* normal sum */
  register float sp_sum; /* for software pipelining */

  /* The CFAR algorithm compares the quotient of signal power of a cell and 
   * the average noise level (sum / num_gates) vs. a specified threshold 
   * (mu), i.e. cell_power / (sum / num_gates) > mu.  Because the number 
   * of gates considered changes depending on whether we are at a border 
   * and divisions are generally more expensive than multiplications, we do 
   * the equivalent comparison: sum < cell_power * (num_gates / mu) = thresh.
   * This also lets us change the number of gates by adding/subtracting 1/mu 
   * to/from a variable that tracks num_gates / mu (numgates_div_mu). */
  register float mu_inv = 1.0 / (float) p_cfar->mu;
  register float numgates_div_mu = (float) ncfar * mu_inv;
  register float thresh;

  /* The CFAR uses a sliding window approach, in which left and right 
   * windows are used to calculate the noise estimate around a particular
   * cell under test.  Note that these windows are not necessarily adjacent
   * to the cell under test; they are always located gcl cells away.
   * The following pointers point to the boundaries of the two windows. */
  register float* p_c2_c;  /* cell under test */
  register float* p_c2_ll; /* left window, left boundary */
  register float* p_c2_lr; /* left window, right boundary */
  register float* p_c2_rl; /* right window, left boundary */
  register float* p_c2_rr; /* right window, right boundary */

  /* Pointers to the data cube and its squared variant.  Because this
   * benchmark is only run once, both pointers are pointing to the same
   * block of memory.  However, if multiple iterations are anticipated,
   * one could allocate a separate cube for the squared values and have
   * p_c2_c point to it instead of the original data cube. */
  register float *p_cube = p_cfar->C_in.data;
  p_c2_c = p_c2_rr = p_cfar->C_in.data;
  
  /* run through each of the dimensions in the CFAR data cube */
  for (i=0; i < nbm; i++) {	
    for (j=0; j < ndop; j++) {
      /* initialize needed pointers */
      p_c2_ll = p_c2_lr = p_c2_c;

      /* The CFAR relies on the square of the signal power in each cell.
       * It calculates these as the right window (specifically p_c2_rr) 
       * reaches them.  However, because the cell under test is separated by 
       * gcl cells from the initial position of the right window, those 
       * cells must be squared in advance. */
      for (k=0; k <= gcl; k++, p_cube++, p_c2_rr++) 
	*p_c2_rr = (*p_cube) * (*p_cube);
      p_c2_rl = p_c2_rr;
      
      /* CASE 0: leftmost cell, full right window. */
      /* initialize the local noise estimate of the right window 
       * (of size ncfar) */
      sum = *p_c2_rr = (*p_cube) * (*p_cube);
      for (k=1, p_c2_rr++, p_cube++; k < ncfar; k++, p_c2_rr++, p_cube++)
	sum += *p_c2_rr = (*p_cube) * (*p_cube);

      /* find targets by comparing to threshold */
      if (sum < *(p_c2_c++) * numgates_div_mu) 
	CfarTargetList_add(p_targetlist, i, j, 0);


      /* from this point on, k should represent the offset of the next 
       * cell under test; i.e. the next cell in the pipeline */
      k = 1;

      /* CASE 1: no cell included on left side of Cfar, full right window,
       * but cell under test is not leftmost cell.  If there are 
       * no guard cells, then we can skip this all together. */
      if (gcl > 0) {
	/* Initialize SW pipeline.  Adjust the noise estimate/threshold
	 * due to the shifting window. */
	*p_c2_rr = (*p_cube) * (*p_cube);
	sum += *(p_c2_rr++) - *(p_c2_rl++);
	thresh = numgates_div_mu * *(p_c2_c++);
	
	for (k++, p_cube++; k <= gcl; k++, p_cube++) {
	  /* previously calculated sum */
	  sp_sum = sum;
	  
	  /* calculate the next local noise estimate due to the shifting window */
	  *p_c2_rr = (*p_cube) * (*p_cube);
	  sum += *(p_c2_rr++) - *(p_c2_rl++);
	  
	  /* find targets using previously calculated sum */
	  if (sp_sum < thresh)
	    CfarTargetList_add(p_targetlist, i, j, k-1);
	  
	  /* adjust the threshold level */
	  thresh = numgates_div_mu * *(p_c2_c++);
	}
	
	/* finish SW pipeline */
	if (sum < thresh) 
	  CfarTargetList_add(p_targetlist, i, j, k-1);
      }

      /* CASE 2: some cells included on left side of Cfar, full right window. 
      *  When this case terminates and the pipeline is finishing, the full left
      *  window is being considered. */

      /* Initialize SW pipeline.  Adjust the number of gates used since 
       * cells on the left side are now being included.  Also adjust
       * noise estimate/threshold due to the shifting window. */
      numgates_div_mu += mu_inv;
      *p_c2_rr = (*p_cube) * (*p_cube);
      sum += *(p_c2_lr++) - *(p_c2_rl++) + *(p_c2_rr++);
      thresh = numgates_div_mu * *(p_c2_c++);

      for (++k, p_cube++; k <= gcl+ncfar; k++, p_cube++) {
	/* previously calculated sum */
	sp_sum = sum;
	  
	/* calculate the next local noise estimate due to the shifting window */
	numgates_div_mu += mu_inv;
	*p_c2_rr = (*p_cube) * (*p_cube);
	sum += *(p_c2_lr++) - *(p_c2_rl++) + *(p_c2_rr++);

	/* find targets using previously calculated sum */
	if (sp_sum < thresh)
	  CfarTargetList_add(p_targetlist, i, j, k-1);

	/* adjust the threshold level */
	thresh = numgates_div_mu * *(p_c2_c++);
      }
      
      /* finish SW pipeline (thresh has the full left window) */
      if (sum < thresh)
	CfarTargetList_add(p_targetlist, i, j, k-1);

    
      /* CASE 3: full windows on both sides of cell under test */

      /* Calculate the number of iterations needed.  The only time this 
       * if-statement will fail is if nrg == (ncfar + gcl) * 2 + 1, 
       * i.e. the number of range gates just fits the two windows, guard 
       * cells and the cell under test.  Thus the cell in the center has 
       * already been taken care of by case 2 so we can skip case 3. */
      if (k < k_diff) {
	/* Initialize SW pipeline.  Adjust noise estimate/threshold due to 
	 * the shifting window. */
	*p_c2_rr = (*p_cube) * (*p_cube);
	sum += *(p_c2_lr++) - *(p_c2_ll++) + *(p_c2_rr++) - *(p_c2_rl++);
	thresh = *(p_c2_c++) * numgates_div_mu;
	
	/* Initialize variables involved in loop */
	for (++k, p_cube++; k < k_diff; k++, p_cube++) {
	  /* previously calculated sum */
	  sp_sum = sum;
	  
	  /* calculate the next local noise estimate due to the shifting window */
	  *p_c2_rr = (*p_cube) * (*p_cube);
	  sum += *(p_c2_lr++) - *(p_c2_ll++) + *(p_c2_rr++) - *(p_c2_rl++);
	  
	  /* find targets using previously calculated sum */
	  if (sp_sum < thresh)
	    CfarTargetList_add(p_targetlist, i, j, k-1);
	  
	  /* adjust the threshold level */
	  thresh = *(p_c2_c++) * numgates_div_mu;
	}
	
	/* finish SW pipeline */
	if (sum < thresh)
	  CfarTargetList_add(p_targetlist, i, j, k-1);
      }

      
      /* CASE 4: some cells included on right side of Cfar, full left window. */

      /* Initialize SW pipeline.  Adjust the number of gates used since 
       * cells on the right side are now being removed.  Also adjust
       * noise estimate/threshold due to the shifting window. */
      numgates_div_mu -= mu_inv;
      sum += *(p_c2_lr++) - *(p_c2_ll++) - *(p_c2_rl++);
      thresh = *(p_c2_c++) * numgates_div_mu;
      
      for (++k; k < nrg-gcl; k++) {
	/* previously calculated sum */
	sp_sum = sum;

	/* calculate the next local noise estimate due to the shifting window */
	numgates_div_mu -= mu_inv;
	sum += *(p_c2_lr++) - *(p_c2_ll++) - *(p_c2_rl++);
	  
	/* find targets using previously calculated sum */
	if (sp_sum < thresh)
	  CfarTargetList_add(p_targetlist, i, j, k-1);

	/* adjust the threshold level */
	thresh = *(p_c2_c++) * numgates_div_mu;
      }

      /* finish SW pipeline */
      if (sum < thresh)
	CfarTargetList_add(p_targetlist, i, j, k-1);


      /* CASE 5: no cell included on right side of Cfar, full left window. 
      *  If there are no guard cells, we can skip this all together. */
      if (gcl > 0) {
	/* Initialize SW pipeline.  Adjust the noise estimate/threshold
	 * due to the shifting window. */
	sum += *(p_c2_lr++) - *(p_c2_ll++);
	thresh = *(p_c2_c++) * numgates_div_mu;
	
	for (++k; k < nrg; k++) {
	  /* previously calculated sum */
	  sp_sum = sum;
	  
	  /* calculate the next local noise estimate due to the shifting window */
	  sum += *(p_c2_lr++) - *(p_c2_ll++);
	  
	  /* find targets using previously calculated sum */
	  if (sp_sum < thresh)
	    CfarTargetList_add(p_targetlist, i, j, k-1);
	  
	  /* adjust the threshold level */
	  thresh = *(p_c2_c++) * numgates_div_mu;
	}
	
	/* finish SW pipeline */
	if (sum < thresh)
	  CfarTargetList_add(p_targetlist, i, j, k-1);
      }
    }
  }
}



/**************************************************************************
* The main function.
**************************************************************************/
int main(int argc, char** argv)
{
  CfarState cfarState;
  CfarTargetList targetlist;
  char *m_paramfile, *m_cubefile, *m_detectfile, *m_timingfile;
  struct PcaCArrayFloat timing;
  pca_timer_t timer;

  /* check arguments */
  if (argc < 2) {
    fprintf(stderr, "Usage: %s [dataset id]\n", argv[0]);
    exit(-1);
  }

  /* prepare timing array */
  pca_create_carray_1d(float, timing, 1, PCA_REAL);

#ifdef VERBOSE
  /* print informative message */
  printf("[Running dataset %s]\n", argv[1]);
#endif

  /* generate needed filenames */
  m_paramfile = (char*) malloc(strlen("data/") + strlen(argv[1]) + 
			       strlen("-cfar-param.dat") + 1);
  sprintf(m_paramfile, "data/%s-cfar-param.dat", argv[1]);
  m_cubefile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
			      strlen("-cfar-cube.dat") + 1);
  sprintf(m_cubefile, "data/%s-cfar-cube.dat", argv[1]);
  m_detectfile = (char*) malloc(strlen("data/") + strlen(argv[1]) + 
				strlen("-cfar-detect.dat") + 1);
  sprintf(m_detectfile, "data/%s-cfar-detect.dat", argv[1]);
  m_timingfile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
				strlen("-cfar-timing.dat") + 1);
  sprintf(m_timingfile, "data/%s-cfar-timing.dat", argv[1]);
  
  /* initialize the CFAR state */
  initCfar(&cfarState, m_paramfile, m_cubefile);
  
  /* initialize target list */
  mm_init(NUM_MM_BLOCKS);
  CfarTargetList_init(&targetlist);

  /* run CFAR */
  timer = startTimer();
  cfar(&cfarState, &targetlist);
  timing.data[0] = stopTimer(timer);
  
  /* print out targets found */
  CfarTargetList_output(m_detectfile, &targetlist);
  
  /* print out timing */
  writeToFile(float, m_timingfile, timing);

  printf("Done.  Latency: %f s.\n", timing.data[0]);
    
  /* cleanup */
  clean_mem(float, cfarState.C_in);
  clean_mem(float, timing);
  CfarTargetList_clean(&targetlist);
  mm_clean();
  free(m_paramfile);
  free(m_cubefile);
  free(m_detectfile);
  free(m_timingfile);

  return 0;
}
/* ----------------------------------------------------------------------------
Copyright (c) 2006, Massachusetts Institute of Technology
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are  
met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of the Massachusetts Institute of Technology nor  
       the names of its contributors may be used to endorse or promote 
       products derived from this software without specific prior written 
       permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  
THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------- */
