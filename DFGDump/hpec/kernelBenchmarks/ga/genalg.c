/******************************************************************************
** File: genalg.c
**
** HPEC Challenge Benchmark Suite
** Genetic Algorithm Kernel Benchmark
**
** Contents:
**  The C version of the genetic algorithm kernel benchmark.
**  Unlike most kernels, which return a single time, this kernel returns
**  multiple times, one per generation.
**
**  Note that the result of the genetic algorithm does not necessarily 
**  converge on the correct answer; please see the description at the top of
**  the genalgVerify.c for more details about this behavior.
**
** Input files (generated by genalgGenerator.m)
**  data/<id>-genalg-param.dat - genetic algorithm parameters
**  data/<id>-genalg-score.dat - matrix used to score chromosomes
**
** Output files: 
**  data/<id>-genalg-elite.dat  - elite chromosome found by the algorithm
**  data/<id>-genalg-timing.dat - timings for each generation
**
** Author: Edmund L. Wong
**         MIT Lincoln Laboratory
**
******************************************************************************/
#include <stdlib.h>
#include <stdio.h>
#include <PcaCTimer.h>
#include <PcaCArray.h>
#include <PcaCRand.h>

#define SEED 42

/* macro that performs a mutation with the specified probability 
   (this only works in genalg() for obvious reasons */
#define try_mutate(x) \
( (hpec_rand() < prm) ? (int) (hpec_rand() * (float) nc) : (x) )

/* useful types */
typedef unsigned int uint;

/* state of the genetic algorithm */
typedef struct
{
  uint num_codes;          /* number of possible values for each gene */
  uint num_genes;          /* number of positions in a chromosome */
  uint max_elite;          /* termination criteria; terminate the genetic
			      algorithm if the number of generations exceed
			      max_elite without a change in the elite
			      chromosome */
  uint num_elite;          /* counter for the above termination criteria */
  uint max_gen;            /* termination criteria; terminate the genetic 
			      algorithm if the number of generations exceed
			      max_gen */
  uint num_gen;            /* counter for the above termination criteria */
  uint num_chromo;         /* number of chromosomes in the population */
  uint best_idx;           /* the index of the best chromosome */
  float max_score;         /* the score of the best chromosome */
  float pr_crossover;      /* probability that crossover will occur for
			      a given pair of chromosomes */
  float pr_mutation;       /* probability of mutation for any 
			      particular gene */
  float pool_score;        /* total score of the population */
  uint* m_curpool;         /* the entire current population */
  uint* m_newpool;         /* the entire next population */
  PcaCArrayFloat score_in; /* the score matrix used to score chromosomes */
  float* m_fitness;        /* the score of each chromosome */
} GenAlgState;


/**************************************************************************
* Evaluates the score of the current generation and updates the needed
* variables within the genetic algorithm state.
**************************************************************************/
void evaluate(GenAlgState* p_genalg)
{
  uint i, j;
  float pscore = 0.0;

  /* useful pointers */
  uint* p_pool = p_genalg->m_curpool;
  float* p_scorecard = p_genalg->score_in.data;
  float* p_fitness = p_genalg->m_fitness;

  /* go through each chromosome and calculate scores */
  p_genalg->best_idx = 0;
  for (i=0; i < p_genalg->num_chromo; i++, p_fitness++) {
    /* calculate the score of a particular chromosome */
    float score = p_scorecard[*p_pool++];
    for (j=1; j < p_genalg->num_genes; j++) 
      score += p_scorecard[j*p_genalg->num_codes + *p_pool++];

    /* divide by the number of genes to keep it between 0.0 and 1.0 
       and record it */
    score /= p_genalg->num_genes;
    *p_fitness = score;
    pscore += score;

    /* see if it is the elite chromosome */
    if (p_genalg->max_score < score) {
      p_genalg->max_score = score;
      p_genalg->best_idx = i;
    }
  }

  /* record the total pool score */
  p_genalg->pool_score = pscore;
}


/**************************************************************************
* Loads the GA parameters and score from the specified files.
**************************************************************************/
void initGA(GenAlgState* p_genalg, const char* p_file, const char* s_file)
{
  /* counters */
  uint i, j;

  /* the arrays to pull in */
  struct PcaCArrayFloat dataset_in; 

  /* read the data from the specified files */
  readFromFile(float, p_file, dataset_in);
  readFromFile(float, s_file, p_genalg->score_in);

  /* load parameters */
  p_genalg->num_codes = (uint) dataset_in.data[0];
  p_genalg->num_genes = (uint) dataset_in.data[1];
  p_genalg->max_elite = (uint) dataset_in.data[2];
  p_genalg->max_gen = (uint) dataset_in.data[3];
  p_genalg->num_chromo = (uint) dataset_in.data[4];
  p_genalg->pr_crossover = dataset_in.data[5];
  p_genalg->pr_mutation = dataset_in.data[6];
  p_genalg->num_elite = 0;
  p_genalg->num_gen = 0;
  p_genalg->best_idx = 0;
  p_genalg->max_score = 0.0;

  /* allocate memory for the necessary data structures */
  p_genalg->m_fitness = malloc(p_genalg->num_chromo * sizeof(float));
  p_genalg->m_curpool = malloc(p_genalg->num_chromo *
			       p_genalg->num_genes *
			       sizeof(int));
  p_genalg->m_newpool = malloc(p_genalg->num_chromo *
			       p_genalg->num_genes *
			       sizeof(int));


  /* generate the initial population */
  for (i=0; i < p_genalg->num_chromo; i++) {
    for (j=0; j < p_genalg->num_genes; j++) {
      p_genalg->m_curpool[i*p_genalg->num_genes + j] = 
	(int) (hpec_rand() * (float) p_genalg->num_codes);
    }
  }

  /* evaluate the initial population */
  evaluate(p_genalg);

  /* clean up */
  clean_mem(float, dataset_in);
}


/**************************************************************************
* Cleans up whatever memory the genetic algorithm used.
**************************************************************************/
void cleanupGA(GenAlgState* p_genalg)
{
  /* clean up memory for the necessary data structures */
  clean_mem(float, p_genalg->score_in);
  free(p_genalg->m_fitness);
  free(p_genalg->m_curpool);
  free(p_genalg->m_newpool);
}


/**************************************************************************
* Runs one generation of the genetic algorithm.  One generation consists
* of the following phases:
*
* 1.  Maintain a unmutated and a mutated copy of the elite chromosome.
* 2.  Select pairs of chromosomes from the current generation for the
*     next generation based on their scores.  Crossover the chromosomes
*     and mutate the individual genes as needed.
* 3.  If an extra slot exists (i.e. if the population is an odd number),
*     fill it with a mutated copy of the elite chromosome.
**************************************************************************/
void genalg(GenAlgState* p_genalg) 
{
  /* local copies of structure members */
  const int pop = p_genalg->num_chromo;
  const int ng = p_genalg->num_genes;
  const int nc = p_genalg->num_codes;
  const float prm = p_genalg->pr_mutation;
  const float prc = p_genalg->pr_crossover;
  float pscore = p_genalg->pool_score;
  uint best_idx = p_genalg->best_idx;

  /* index for referencing the pools */
  int i, j;

  /* pointers used in genetic algorithm */
  float* p_fitness;

  /* used to swap the pools */
  uint *p_swappool;

  /* a pair of chromosomes is considered during each generation, thus 
     we need two pointers to select from the current generation */
  register uint* p_old = &(p_genalg->m_curpool)[best_idx*ng];
  register uint* p_old2 = &(p_genalg->m_curpool)[best_idx*ng];

  /* pointers used for placing chromosomes into the new generation,
     one for each in the selected pair */
  register uint* p_new = p_genalg->m_newpool;
  register uint* p_new2 = &(p_genalg->m_newpool)[(pop >> 1) * ng];


  /* Elitism phase - best chromosome guaranteed in next generation PLUS 
     make another copy of the elite chromosome that will be mutated */
  for (j=0; j < ng; j++, p_old++, p_new++, p_new2++) {
    *p_new  = *p_old;
    *p_new2 = try_mutate(*p_old);
  }

  /* Selection phase - select a pair of chromosomes at the same time to 
     fill up the new generation */
  for (i=2; i < pop-1; i += 2) {
    /* random counter variables */
    int c = 0;
    int x = 0;
    int y = 0;

    /* used to select two random chromosomes */
    float rx, ry;

    /* reset the fitness pointer */
    p_fitness = p_genalg->m_fitness;

    /* Perform selection by generating a random number between 0 and the 
       total score of the generation.  Then starting from the first
       chromosome, add the scores of each chromosome until the score
       exceeds our randomly generated number.  The last chromosome added 
       is thus selected.  We do this for two chromosomes at the same time. */
    rx = hpec_rand() * pscore - *p_fitness;
    ry = hpec_rand() * pscore - *p_fitness;
    for (c=0, p_fitness++; 
	 rx > 0.0 && ry > 0.0 && c < pop-1; 
	 c++, p_fitness++) 
    {
      rx -= *p_fitness;
      ry -= *p_fitness;
    }

    /* note that at most one of the following two should actually enter 
       the for loop */
    for (x=c; rx > 0.0 && x < pop-1; x++, p_fitness++) rx -= *p_fitness;
    for (y=c; ry > 0.0 && y < pop-1; y++, p_fitness++) ry -= *p_fitness;

    /* point our pointers to the selected chromosomes */
    p_old  = p_genalg->m_curpool + x*ng;
    p_old2 = p_genalg->m_curpool + y*ng;

    /* Crossover/mutation - with certain specified probabilities, 
       switch the gene values between two chromosomes and possibly
       mutate these values */
    j = 0;
    if (hpec_rand() < prc) {
      /* do a crossover from 0 to site */
      int site = (int) (hpec_rand() * (float) ng);
      for ( ; j < site; j++, p_old++, p_old2++, p_new++, p_new2++) {
	*p_new = try_mutate(*p_old2);
	*p_new2 = try_mutate(*p_old);
      }
    }

    /* finish off anything that has not been done by the crossover 
       code above (mutation still occurs here) */
    for ( ; j < ng; j++, p_old++, p_old2++, p_new++, p_new2++) {
      *p_new = try_mutate(*p_old);
      *p_new2 = try_mutate(*p_old2);
    }
  }

  /* if there is an odd number of chromosomes, place a possibly mutated 
     version of the elite chromosome there */
  if (pop & 1) {
    int j;
    p_old = &(p_genalg->m_curpool)[best_idx*ng];
    for (j = 0; j < ng; j++, p_old++, p_new2++) {
      *p_new2 = try_mutate(*p_old);
    }
  }
  
  /* switch the pointers so that next time genalg() is run, the current
     generation pointer points to just-created generation rather than
     the old one */
  p_swappool = p_genalg->m_newpool;
  p_genalg->m_newpool = p_genalg->m_curpool;
  p_genalg->m_curpool = p_swappool;

  /* evaluate the fitness of the new population */
  evaluate(p_genalg);
}


/**************************************************************************
* Outputs the elite chromosome to the specified filename.
**************************************************************************/
void outputEliteChromosome(const char* filename, GenAlgState* p_genalg)
{
  uint *p_elite = &(p_genalg->m_curpool[p_genalg->best_idx*
					p_genalg->num_genes]);
  struct PcaCArrayInt output;
  uint i;

  /* create the output array */
  pca_create_carray_1d(int, output, p_genalg->num_genes, PCA_REAL);
  for (i = 0; i < p_genalg->num_genes; i++)
    output.data[i] = p_elite[i]+1;
  
  /* output to file */
  writeToFile(int, filename, output);

  /* clean up */
  clean_mem(int, output);
}


/**************************************************************************
* The main function.
**************************************************************************/
int main(int argc, char** argv)
{
  uint i = 0;
  float timeSum = 0.0;

  /* used to maintain state of the genetic algorithm between iterations */
  GenAlgState gaState;

  /* for timing purposes */
  struct PcaCArrayFloat timing;
  float* m_timing;
  pca_timer_t timer;

  /* the filenames needed for input/output */
  char *m_paramfile, *m_scorefile, *m_elitefile, *m_timingfile;

  /* check arguments */
  if (argc != 2) {
    fprintf(stderr, "Usage: %s [dataset id]\n", argv[0]);
    exit(-1);
  }

  /* generate needed filenames */
  m_paramfile = (char*) malloc(strlen("data/") + strlen(argv[1]) + 
			       strlen("-genalg-param.dat") + 1);
  sprintf(m_paramfile, "data/%s-genalg-param.dat", argv[1]);
  m_scorefile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
			       strlen("-genalg-score.dat") + 1);
  sprintf(m_scorefile, "data/%s-genalg-score.dat", argv[1]);
  m_elitefile = (char*) malloc(strlen("data/") + strlen(argv[1]) + 
			       strlen("-genalg-elite.dat") + 1);
  sprintf(m_elitefile, "data/%s-genalg-elite.dat", argv[1]);
  m_timingfile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
				strlen("-genalg-timing.dat") + 1);
  sprintf(m_timingfile, "data/%s-genalg-timing.dat", argv[1]);

#ifdef VERBOSE
  /* print informative message */
  printf("[Running dataset %s]\n", argv[1]);
#endif

  /* initialize seed */
  hpec_srand(SEED);
  
  /* load data */
  initGA(&gaState, m_paramfile, m_scorefile);
  
  /* run the genetic algorithm a specified number of times */
  m_timing = (float*) malloc(sizeof(float) * gaState.max_gen);
  while (gaState.num_gen < gaState.max_gen &&
	 gaState.num_elite < gaState.max_elite) 
  {
    /* run one generation of the genetic algorithm */
    timer = startTimer();
    genalg(&gaState);

    /* increment variables */ 
    gaState.num_gen++;
    gaState.num_elite = !(gaState.best_idx) ? gaState.num_elite+1 : 0;

    /* timing */
    m_timing[gaState.num_gen - 1] = stopTimer(timer);
    timeSum += m_timing[gaState.num_gen - 1];
  }

  /* done; output the elite chromosome */

  outputEliteChromosome(m_elitefile, &gaState);
#ifdef VERBOSE
  printf("DONE: Generations = %d, elite score = %f, elite count = %d\n",
	 gaState.num_gen, gaState.max_score, gaState.num_elite);
#endif
  printf("Done.  Latency: %f s.\n", timeSum/((float)gaState.num_gen));
  
  /* output timing */
  pca_create_carray_1d(float, timing, gaState.num_gen, PCA_REAL);
  for (i = 0; i < gaState.num_gen; i++)
    timing.data[i] = m_timing[i];
  writeToFile(float, m_timingfile, timing); 
  
  /* clean up */
  cleanupGA(&gaState);
  clean_mem(float, timing); 
  free(m_timing);
  free(m_paramfile);
  free(m_scorefile);
  free(m_elitefile);
  free(m_timingfile);
  return 0;
}
/* ----------------------------------------------------------------------------
Copyright (c) 2006, Massachusetts Institute of Technology
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are  
met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of the Massachusetts Institute of Technology nor  
       the names of its contributors may be used to endorse or promote 
       products derived from this software without specific prior written 
       permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  
THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------- */
