/******************************************************************************
** File: db.c
**
** HPEC Challenge Benchmark Suite
** Database Kernel Benchmark
**
** Contents:
** Contents:
**  The C version of the database kernel benchmark.  This kernel simulates
**  a database by performing operations on structures typically used
**  in databases.  The main structure used is a red-black tree which 
**  performs the necessary search/insert/delete operations.  The tree nodes 
**  point to database track records that contain the info that is stored 
**  in the database. This is done by running and timing a set number of 
**  each operation (insert/delete/search) each cycle.  Timings for each 
**  cycle are then output to a file. 
**
** Input files (generated by dbGenerator.m)
**  data/<id>-db-param.dat - database parameters
**  data/<id>-db-inst.dat  - list of instructions to execute
**
** Output files: 
**  data/<id>-cfar-results.dat - number of targets found during each search
**  data/<id>-cfar-timing.dat  - timings for each generation
**
** Author: Edmund L. Wong
**         MIT Lincoln Laboratory
**
******************************************************************************/
#include <PcaCTimer.h>
#include "dbmem.h"
#include "rbtree.h"
#include "list.h"

/* number of blocks to allocate at once for the various structures; 
 * used to control the MemManager
 * (LL = linked list, RB = red-black tree, TR = database track records) */
#define NUM_LL_BLOCKS 50
#define NUM_RB_BLOCKS 20
#define NUM_TR_BLOCKS 20

/* flags used by the generator to denote various types of instructions */
#define END_OF_CYCLE_FLAG  0.0
#define SEARCH_OP_FLAG    -0.5
#define INSERT_OP_FLAG    -1.0
#define DELETE_OP_FLAG    -1.5


/**************************************************************************
* The track record entries.
**************************************************************************/
struct TrackRecordStruct
{
  /* record id */
  int id;

  /* coordinates */
  float x, y;
};


/**************************************************************************
* Database commands.
**************************************************************************/
typedef enum { SELECT, INSERT, DELETE, END } cmd_t;
typedef struct
{
  /* the actual type of command */
  cmd_t cmdType;

  /* the coordinates that are used by various commands; insert/delete use 
   * (x0, y0), select uses all. */
  float x0, y0, x1, y1;
} DBCmd;

/**************************************************************************
* Database state.
**************************************************************************/
typedef struct
{
  /* keeps track of what's in the db and what's not */
  RedBlackTree searchTree;

  /* command list */
  DBCmd* m_cmds;
  DBCmd* p_currcmd;
  DBCmd* p_lastcmd;

  /* test parameters */
  int total_records;     /* total number of records */
  int num_cycles;        /* number of cycles */
  int M;                 /* number of grid rows */
  int N;                 /* number of grid columns */
  int dX;                /* grid row search size */
  int dY;                /* grid col search size */
  int search_cycle;      /* search ops/cycle (loaded from file) */
  int insert_cycle;      /* insert ops/cycle (loaded from file) */
  int delete_cycle;      /* delete ops/cycle (loaded from file) */
  int max_id;            /* keeps track of the max id used */
  PcaCArrayInt sresults; /* search results */
  int sresults_idx;      /* search results index */
} DBState;



/**************************************************************************
* Initializes a end marker.
**************************************************************************/
void DBCmd_initEnd(DBCmd* p_cmd)
{
  p_cmd->cmdType = END;
}


/**************************************************************************
* Initializes an insert command.
**************************************************************************/
void DBCmd_initInsert(DBCmd* p_cmd, float f0, float f1)
{
  p_cmd->cmdType = INSERT;
  p_cmd->x0 = f0;
  p_cmd->y0 = f1;
}


/**************************************************************************
* Initializes a delete command.
**************************************************************************/
void DBCmd_initDelete(DBCmd* p_cmd, float f0, float f1)
{
  p_cmd->cmdType = DELETE;
  p_cmd->x0 = f0;
  p_cmd->y0 = f1;
}


/**************************************************************************
* Initializes a search command.
**************************************************************************/
void DBCmd_initSelect(DBCmd* p_cmd, float f0, float f1, float f2, float f3)
{
  p_cmd->cmdType = SELECT;
  p_cmd->x0 = f0;
  p_cmd->y0 = f1;
  p_cmd->x1 = f2;
  p_cmd->y1 = f3;
}



/**************************************************************************
* "Cleans up" a database command.  Placeholder for consistency.
**************************************************************************/
void DBCmd_clean(DBCmd* p_rv) 
{
  /* do nothing */
}


/**************************************************************************
* Creates a database track record.
**************************************************************************/
TrackRecord* TrackRecord_create(int id, float c0, float c1)
{
  TrackRecord* p_rv = (TrackRecord*) tr_malloc();
  p_rv->id = id;
  p_rv->x = c0;
  p_rv->y = c1;
  return p_rv;
}


/**************************************************************************
* Frees up memory used by a database track record.
**************************************************************************/
void TrackRecord_destroy(TrackRecord* p_rv) 
{
  tr_free(p_rv);
}



/**************************************************************************
* Check for equality.
**************************************************************************/
bool TrackRecord_isequal(TrackRecord* p_tr0, TrackRecord* p_tr1)
{
  return (p_tr0->x == p_tr1->x) && (p_tr0->y == p_tr1->y);
}



/**************************************************************************
* Loads the parameter and instruction list files.  Loads in parameters,
* initializes the instruction list, and places the initial targets into
* the database.
**************************************************************************/
void DBState_load(DBState* p_state, char* m_paramfile, char* m_instfile)
{
  /* random index variables */
  int i = 0;

  /* input data */
  struct PcaCArrayInt info_in;
  struct PcaCArrayFloat inst_in;

  /* read in data files */
  readFromFile(int, m_paramfile, info_in);
  readFromFile(float, m_instfile, inst_in);

  p_state->M = info_in.data[1];
  p_state->N = info_in.data[2];
  p_state->delete_cycle = info_in.data[3];
  p_state->insert_cycle = info_in.data[4];
  p_state->search_cycle = info_in.data[5];
  p_state->num_cycles = info_in.data[6];
  p_state->total_records = info_in.data[7];
  p_state->dX = info_in.data[8];
  p_state->dY = info_in.data[9];

  /* keeps track of the max id used */
  p_state->max_id = 0;

  /* initialize needed data structures */
  RedBlackTree_init(&p_state->searchTree);

  /* place initial targets */
  if (inst_in.data[i] != INSERT_OP_FLAG) {
    fprintf(stderr, "%s: Missing initial insert operation flag; "
	    "please rerun dbGenerator().\n", m_instfile);
    exit(-1);
  } 
  while (i < inst_in.size[0] && inst_in.data[i] != END_OF_CYCLE_FLAG) 
  {
    TrackRecord* p_tr = TrackRecord_create(p_state->max_id++, 
					   inst_in.data[i+1],
					   inst_in.data[i+2]);
    RedBlackTree_insert(&p_state->searchTree, p_tr->x, p_tr); 
    i += 3;
  }

#ifdef VERBOSE
  /* print out status message */
  printf("Placed %d targets, stored %d targets.\n", 
	 RedBlackTree_size(&p_state->searchTree), 
	 p_state->total_records-RedBlackTree_size(&p_state->searchTree));
#endif

  /* create the command array */
  p_state->m_cmds = (DBCmd*) malloc(sizeof(DBCmd)*p_state->num_cycles*
				    (p_state->search_cycle + 
				     p_state->insert_cycle + 
				     p_state->delete_cycle + 1));
  p_state->p_currcmd = p_state->m_cmds;

  /* read in the instructions */
  while (++i < inst_in.size[0]) {
    if (inst_in.data[i] == INSERT_OP_FLAG) {
      DBCmd_initInsert(p_state->p_currcmd++, inst_in.data[i+1], inst_in.data[i+2]);
      i += 2;
    }
    else if (inst_in.data[i] == SEARCH_OP_FLAG) {
      DBCmd_initSelect(p_state->p_currcmd++, inst_in.data[i+1], inst_in.data[i+2], 
		       inst_in.data[i+3], inst_in.data[i+4]);
      i += 4;
    }
    else if (inst_in.data[i] == DELETE_OP_FLAG) {
      DBCmd_initDelete(p_state->p_currcmd++, inst_in.data[i+1], inst_in.data[i+2]);
      i += 2;
    }
    else if (inst_in.data[i] == END_OF_CYCLE_FLAG) {
      DBCmd_initEnd(p_state->p_currcmd++);
    }
    else {
      fprintf(stderr, "%s: Unrecognized instruction type (%f); "
	      "please rerun dbGenerator().\n", m_instfile, inst_in.data[i]);
      exit(-1);
    }
  }

  /* determine number of instructions generated */
  p_state->p_lastcmd = p_state->p_currcmd;
  p_state->p_currcmd = p_state->m_cmds;
#ifdef VERBOSE
  printf("Loaded %d instruction(s).\n", 
	 p_state->p_lastcmd - p_state->p_currcmd - p_state->num_cycles);
#endif

  /* create the search results array */
  pca_create_carray_1d(int, p_state->sresults, p_state->search_cycle*
		       p_state->num_cycles, PCA_REAL);
  p_state->sresults_idx = 0;

  /* free up memory used by data generation structures and loading */
  clean_mem(int, info_in);
  clean_mem(float, inst_in);
}


/**************************************************************************
* Run the database for one cycle.
**************************************************************************/
void runDatabase(DBState* p_state)
{
  RedBlackTree* p_searchTree = &p_state->searchTree;
  DBCmd *p_currcmd = p_state->p_currcmd, *p_lastcmd = p_state->p_lastcmd;

  for ( ; p_currcmd < p_lastcmd; p_currcmd++)
  {
    /* run thru the list of stored commands */
    switch(p_currcmd->cmdType) {
    case INSERT:
    {
      RedBlackTree_insert(p_searchTree, p_currcmd->x0, 
			  TrackRecord_create(p_state->max_id++, 
					     p_currcmd->x0, 
					     p_currcmd->y0));
      break;
    }
    case DELETE:
    {
      /* initialize a red-black iterator to point to the first
       * node in the tree that has a particular key (x coordinate) */
      RedBlackIterator rb_it; 
      TrackRecord* p_tr;
      RedBlackTree_find(&rb_it, p_searchTree, p_currcmd->x0);

      /* now iterate until we get to the next key, reach the end
       * of the tree, or find the value we want (y coordinate) */
      while (!rb_it.atEnd && 
	     (RedBlackIterator_value(&rb_it)->x == p_currcmd->x0) &&
	     (RedBlackIterator_value(&rb_it)->y != p_currcmd->y0)) 
      {
	RedBlackIterator_next(&rb_it);
      }

      /* if we found the value we want, try to remove it */
      if (RedBlackIterator_value(&rb_it)->x != p_currcmd->x0 ||
	  RedBlackIterator_value(&rb_it)->y != p_currcmd->y0 || 
	  !RedBlackIterator_remove(&rb_it, &p_tr))
      {
	fprintf(stderr, "ERROR in removing target (%f, %f)!  Exiting...\n",
		p_currcmd->x0, p_currcmd->y0);
	exit(-1);
      }

      /* destroy the track record */
      TrackRecord_destroy(p_tr);
      break;
    }

    case SELECT:
    {
      RedBlackIterator rb_it;
      int volatile id;
      uint count = 0;

      /* initialize iterator to point to the first node with key larger 
       * than x0 */
      RedBlackTree_findNextLargest(&rb_it, p_searchTree,
				   p_currcmd->x0);

      /* while we haven't reached the end of the tree and while
       * we are within bounds (x0 < current < x1), continue
       * finding targets (y0 < current < y1) and tracking them */
      while (!rb_it.atEnd) {
	TrackRecord* p_target = RedBlackIterator_value(&rb_it);
	if (p_target->x >= p_currcmd->x1) break; 
	if (p_target->x < p_currcmd->x1 && 
	    p_target->y > p_currcmd->y0 && 
	    p_target->y < p_currcmd->y1) 
	{
	  /* get their data and copy it somewhere */
	  id = p_target->id;

	  /* keep track of how many we've found */
	  count++;
	}
	RedBlackIterator_next(&rb_it);
      }

      /* track how many we've found */
      p_state->sresults.data[p_state->sresults_idx++] = count;
      break;
    }

    case END:
    {
      /* we're done for this cycle */
      p_state->p_currcmd = p_currcmd + 1;
      return;
    }

    default:
      fprintf(stderr, "Unrecognized command [cmd = %d]!  Exiting...",
	      p_currcmd->cmdType);
      exit(-1);
    }
  }
  p_state->p_currcmd = p_currcmd;
}


/**************************************************************************
* Cleans up after completion on a particular data set size.
**************************************************************************/
void DBState_clean(DBState* p_state) 
{
  RedBlackTree_clean(&p_state->searchTree);
  clean_mem(int, p_state->sresults);
  free(p_state->m_cmds);
}


/**************************************************************************
* The main function.
**************************************************************************/
int main(int argc, char** argv)
{
  DBState dbState;
  char *m_paramfile, *m_instfile, *m_timefile, *m_resfile;
  pca_timer_t timer;
  PcaCArrayFloat timing;
  uint i = 0;
  float timeSum = 0.0;

  /* check arguments */
  if (argc < 2) {
    fprintf(stderr, "Usage: %s [dataset idx]\n", argv[0]);
    exit(-1);
  }
    
  /* initialize memory managers */
#ifdef VERBOSE
#ifdef PCA_DB_MEM
  printf("Using custom memory management.\n");
#else
  printf("Using standard malloc/free.\n");
#endif
#endif
  ll_init(NUM_LL_BLOCKS);
  rb_init(NUM_RB_BLOCKS);
  tr_init(NUM_TR_BLOCKS);

  /* load up db state and create timing array */
  m_paramfile = (char*) malloc(strlen("data/") + strlen(argv[1]) + 
			       strlen("-db-param.dat") + 1);
  m_instfile = (char*)  malloc(strlen("data/") + strlen(argv[1]) + 
			       strlen("-db-inst.dat") + 1);
  sprintf(m_paramfile, "data/%s-db-param.dat", argv[1]);
  sprintf(m_instfile, "data/%s-db-inst.dat", argv[1]);
  DBState_load(&dbState, m_paramfile, m_instfile);
  pca_create_carray_1d(float, timing, dbState.num_cycles, PCA_REAL);

  /* run the database */
#ifdef VERBOSE
  printf("Running with %d total record(s)... ", dbState.total_records);
#endif
  while (dbState.p_currcmd < dbState.p_lastcmd) {
    timer = startTimer();
    runDatabase(&dbState);
    timing.data[i++] = stopTimer(timer);
    timeSum = timeSum + timing.data[i-1];
  }
  printf("Done.  Latency: %f s.\n", timeSum/((float)dbState.num_cycles));

  /* output timings */
  m_timefile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
			      strlen("-db-timing.dat") + 1);
  sprintf(m_timefile, "data/%s-db-timing.dat", argv[1]);
  writeToFile(float, m_timefile, timing);
  clean_mem(float, timing);

  /* output results of database */
  m_resfile = (char*) malloc(strlen("data/") + strlen(argv[1]) +
			     strlen("-db-results.dat") + 1);
  sprintf(m_resfile, "data/%s-db-results.dat", argv[1]);
  writeToFile(int, m_resfile, dbState.sresults);

  /* cleanup */ 
  free(m_paramfile);
  free(m_instfile);
  free(m_timefile);
  free(m_resfile);
  DBState_clean(&dbState);
  ll_clean();
  rb_clean();
  tr_clean();

  return 0;
}
/* ----------------------------------------------------------------------------
Copyright (c) 2006, Massachusetts Institute of Technology
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are  
met:
     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.
     * Neither the name of the Massachusetts Institute of Technology nor  
       the names of its contributors may be used to endorse or promote 
       products derived from this software without specific prior written 
       permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  
THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------- */
